<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Golden age">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Golden age">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LiuXin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Golden age</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Golden age</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">LiuXin的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/GoldenageLiux" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/16/toc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LiuXin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Golden age">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/16/toc/" class="post-title-link" itemprop="url">目录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-16 12:37:58 / 修改时间：12:38:19" itemprop="dateCreated datePublished" datetime="2022-05-16T12:37:58+08:00">2022-05-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8E%B0%E4%BB%A3C-%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">现代C++教程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="现代-C-教程：高速上手-C-11-x2F-14-x2F-17-x2F-20"><a href="#现代-C-教程：高速上手-C-11-x2F-14-x2F-17-x2F-20" class="headerlink" title="现代 C++ 教程：高速上手 C++ 11&#x2F;14&#x2F;17&#x2F;20"></a>现代 C++ 教程：高速上手 C++ 11&#x2F;14&#x2F;17&#x2F;20</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="../00-preface.md"><strong>序言</strong></a></li>
<li><a href="../01-intro.md"><strong>第 1 章 迈向现代 C++</strong></a><ul>
<li>1.1 被弃用的特性</li>
<li>1.2 与 C 的兼容性</li>
<li>进一步阅读的参考文献</li>
</ul>
</li>
<li><a href="../02-usability.md"><strong>第 2 章 语言可用性的强化</strong></a><ul>
<li>2.1 常量<ul>
<li>nullptr</li>
<li>constexpr</li>
</ul>
</li>
<li>2.2 变量及其初始化<ul>
<li>if&#x2F;switch 变量声明强化</li>
<li>初始化列表</li>
<li>结构化绑定</li>
</ul>
</li>
<li>2.3 类型推导<ul>
<li>auto</li>
<li>decltype</li>
<li>尾返回类型</li>
<li>decltype(auto)</li>
</ul>
</li>
<li>2.4 控制流<ul>
<li>if constexpr</li>
<li>区间 for 迭代</li>
</ul>
</li>
<li>2.5 模板<ul>
<li>外部模板</li>
<li>尖括号 “&gt;”</li>
<li>类型别名模板</li>
<li>默认模板参数</li>
<li>变长参数模板</li>
<li>折叠表达式</li>
<li>非类型模板参数推导</li>
</ul>
</li>
<li>2.6 面向对象<ul>
<li>委托构造</li>
<li>继承构造</li>
<li>显式虚函数重载</li>
<li>override</li>
<li>final</li>
<li>显式禁用默认函数</li>
<li>强类型枚举</li>
</ul>
</li>
</ul>
</li>
<li><a href="../03-runtime.md"><strong>第 3 章 语言运行期的强化</strong></a><ul>
<li>3.1 lambda 表达式<ul>
<li>基础</li>
<li>泛型</li>
</ul>
</li>
<li>3.2 函数对象包装器<ul>
<li>std::function</li>
<li>std::bind 和 std::placeholder</li>
</ul>
</li>
<li>3.3 右值引用<ul>
<li>左值、右值的纯右值、将亡值、右值</li>
<li>右值引用和左值引用</li>
<li>移动语义</li>
<li>完美转发</li>
</ul>
</li>
</ul>
</li>
<li><a href="../04-containers.md"><strong>第 4 章 标准库: 容器</strong></a><ul>
<li>4.1 线性容器<ul>
<li><code>std::array</code></li>
<li><code>std::forward_list</code></li>
</ul>
</li>
<li>4.2 无序容器<ul>
<li><code>std::unordered_set</code></li>
<li><code>std::unordered_map</code></li>
</ul>
</li>
<li>4.3 元组 <code>std::tuple</code><ul>
<li>基本操作</li>
<li>运行期索引 <code>std::variant</code></li>
<li>合并与迭代</li>
</ul>
</li>
</ul>
</li>
<li><a href="../05-pointers.md"><strong>第 5 章 标准库: 指针</strong></a><ul>
<li>5.1 RAII 与引用计数</li>
<li>5.2 <code>std::shared_ptr</code></li>
<li>5.3 <code>std::unique_ptr</code></li>
<li>5.4 <code>std::weak_ptr</code></li>
</ul>
</li>
<li><a href="../06-regex.md"><strong>第 6 章 标准库: 正则表达式</strong></a><ul>
<li>6.1 正则表达式简介<ul>
<li>普通字符</li>
<li>特殊字符</li>
<li>限定符</li>
</ul>
</li>
<li>6.2 <code>std::regex</code> 及其相关<ul>
<li><code>std::regex</code></li>
<li><code>std::regex_match</code></li>
<li><code>std::match_results</code></li>
</ul>
</li>
</ul>
</li>
<li><a href="../07-thread.md"><strong>第 7 章 并行与并发</strong></a><ul>
<li>7.1 并行基础</li>
<li>7.2 互斥量与临界区</li>
<li>7.3 期物</li>
<li>7.4 条件变量</li>
<li>7.5 原子操作与内存模型<ul>
<li>原子操作</li>
<li>一致性模型</li>
<li>内存顺序</li>
</ul>
</li>
</ul>
</li>
<li><a href="../08-filesystem.md"><strong>第 8 章 文件系统</strong></a><ul>
<li>8.1 文档与链接</li>
<li>8.2 <code>std::filesystem</code></li>
</ul>
</li>
<li><a href="../09-others.md"><strong>第 9 章 其他杂项</strong></a><ul>
<li>9.1 新类型<ul>
<li><code>long long int</code></li>
</ul>
</li>
<li>9.2 <code>noexcept</code> 的修饰和操作</li>
<li>9.3 字面量<ul>
<li>原始字符串字面量</li>
<li>自定义字面量</li>
</ul>
</li>
<li>9.4 内存对齐</li>
</ul>
</li>
<li><a href="../10-cpp20.md"><strong>第 10 章 展望: C++20 简介</strong></a><ul>
<li>10.1 Concept</li>
<li>10.2 Range</li>
<li>10.3 Module</li>
<li>10.4 Coroutine</li>
<li>10.5 事务内存</li>
</ul>
</li>
<li><a href="../appendix1.md"><strong>附录 1：进一步阅读的学习材料</strong></a></li>
<li><a href="../appendix2.md"><strong>附录 2：现代 C++ 的最佳实践</strong></a></li>
</ul>
<p>返回目录 | 上一章 | <a href="../00-preface.md">下一章：序言</a></p>
<h2 id="许可"><a href="#许可" class="headerlink" title="许可"></a>许可</h2><p><a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png" /></a></p>
<p>本书系<a target="_blank" rel="noopener" href="https://github.com/changkun">欧长坤</a>著，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>许可。项目中代码使用 MIT 协议开源，参见<a href="../../LICENSE">许可</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/14/03-runtime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LiuXin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Golden age">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/14/03-runtime/" class="post-title-link" itemprop="url">第 3 章 语言运行期的强化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-14 21:13:58" itemprop="dateCreated datePublished" datetime="2022-05-14T21:13:58+08:00">2022-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-16 12:36:21" itemprop="dateModified" datetime="2022-05-16T12:36:21+08:00">2022-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8E%B0%E4%BB%A3C-%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">现代C++教程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第-3-章-语言运行期的强化"><a href="#第-3-章-语言运行期的强化" class="headerlink" title="第 3 章 语言运行期的强化"></a>第 3 章 语言运行期的强化</h1><h2 id="3-1-Lambda-表达式"><a href="#3-1-Lambda-表达式" class="headerlink" title="3.1 Lambda 表达式"></a>3.1 Lambda 表达式</h2><p>Lambda 表达式是现代 C++ 中最重要的特性之一，而 Lambda 表达式，实际上就是提供了一个类似匿名函数的特性，<br>而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。这样的场景其实有很多很多，<br>所以匿名函数几乎是现代编程语言的标配。</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>Lambda 表达式的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[捕获列表](参数列表) mutable(可选) 异常属性 -&gt; 返回类型 &#123;</span><br><span class="line">// 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的语法规则除了 <code>[捕获列表]</code> 内的东西外，其他部分都很好理解，只是一般函数的函数名被略去，<br>返回值使用了一个 <code>-&gt;</code> 的形式进行（我们在上一节前面的尾返回类型已经提到过这种写法了）。</p>
<p>所谓捕获列表，其实可以理解为参数的一种类型，Lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的，<br>这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种：</p>
<h4 id="1-值捕获"><a href="#1-值捕获" class="headerlink" title="1. 值捕获"></a>1. 值捕获</h4><p>与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝，<br>而非调用时才拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_value_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = <span class="built_in">copy_value</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stored_value = &quot;</span> &lt;&lt; stored_value &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这时, stored_value == 1, 而 value == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value 在创建时就保存了一份 value 的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-引用捕获"><a href="#2-引用捕获" class="headerlink" title="2. 引用捕获"></a>2. 引用捕获</h4><p>与引用传参类似，引用捕获保存的是引用，值会发生变化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_reference_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [&amp;value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = <span class="built_in">copy_value</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stored_value = &quot;</span> &lt;&lt; stored_value &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这时, stored_value == 100, value == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value 保存的是引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-隐式捕获"><a href="#3-隐式捕获" class="headerlink" title="3. 隐式捕获"></a>3. 隐式捕获</h4><p>手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个<br><code>&amp;</code> 或 <code>=</code> 向编译器声明采用引用捕获或者值捕获.</p>
<p>总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是：</p>
<ul>
<li>[] 空捕获列表</li>
<li>[name1, name2, …] 捕获一系列变量</li>
<li>[&amp;] 引用捕获, 让编译器自行推导引用列表</li>
<li>[&#x3D;] 值捕获, 让编译器自行推导值捕获列表</li>
</ul>
<h4 id="4-表达式捕获"><a href="#4-表达式捕获" class="headerlink" title="4. 表达式捕获"></a>4. 表达式捕获</h4><blockquote>
<p>这部分内容需要了解后面马上要提到的右值引用以及智能指针</p>
</blockquote>
<p>上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左值，而不能捕获右值。</p>
<p>C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获，<br>被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 <code>auto</code> 本质上是相同的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  <span class="comment">// std::make_unique</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_expression_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> important = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> add = [v1 = <span class="number">1</span>, v2 = std::<span class="built_in">move</span>(important)](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y+v1+(*v2);</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，important 是一个独占指针，是不能够被 “&#x3D;” 值捕获到，这时候我们可以将其转移为右值，在表达式中初始化。</p>
<h3 id="泛型-Lambda"><a href="#泛型-Lambda" class="headerlink" title="泛型 Lambda"></a>泛型 Lambda</h3><p>上一节中我们提到了 <code>auto</code> 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生冲突。<br>但是 Lambda 表达式并不是普通函数，所以 Lambda 表达式并不能够模板化。<br>这就为我们造成了一定程度上的麻烦：参数表不能够泛化，必须明确参数表类型。</p>
<p>幸运的是，这种麻烦只存在于 C++11 中，从 C++14 开始，<br>Lambda 函数的形式参数可以使用 <code>auto</code> 关键字来产生意义上的泛型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1.1</span>, <span class="number">2.2</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-2-函数对象包装器"><a href="#3-2-函数对象包装器" class="headerlink" title="3.2 函数对象包装器"></a>3.2 函数对象包装器</h2><p>这部分内容虽然属于标准库的一部分，但是从本质上来看，它却增强了 C++ 语言运行时的能力，<br>这部分内容也相当重要，所以放到这里来进行介绍。</p>
<h3 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a><code>std::function</code></h3><p>Lambda 表达式的本质是一个和函数对象类型相似的类类型（称为闭包类型）的对象（称为闭包对象），<br>当 Lambda 表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> foo = <span class="built_in">void</span>(<span class="type">int</span>); <span class="comment">// 定义函数类型, using 的使用见上一节中的别名语法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functional</span><span class="params">(foo f)</span> </span>&#123; <span class="comment">// 定义在参数列表中的函数类型 foo 被视为退化后的函数指针类型 foo*</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = [](<span class="type">int</span> value) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">functional</span>(f); <span class="comment">// 传递闭包对象，隐式转换为 foo* 类型的函数指针值</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// lambda 表达式调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数类型传递进行调用，<br>而另一种则是直接调用 Lambda 表达式，在 C++11 中，统一了这些概念，将能够被调用的对象的类型，<br>统一称之为可调用类型。而这种类型，便是通过 <code>std::function</code> 引入的。</p>
<p>C++11 <code>std::function</code> 是一种通用、多态的函数封装，<br>它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作，<br>它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的），<br>换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。<br>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> para)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::function 包装了一个返回值为 int, 参数为 int 的函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func = foo;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> important = <span class="number">10</span>;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func2 = [&amp;](<span class="type">int</span> value) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+value+important;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func2</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="std-bind-和-std-placeholder"><a href="#std-bind-和-std-placeholder" class="headerlink" title="std::bind 和 std::placeholder"></a><code>std::bind</code> 和 <code>std::placeholder</code></h3><p>而 <code>std::bind</code> 则是用来绑定函数调用的参数的，<br>它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数，<br>我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。<br>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将参数1,2绑定到函数 foo 上，但是使用 std::placeholders::_1 来对第一个参数进行占位</span></span><br><span class="line">    <span class="keyword">auto</span> bindFoo = std::<span class="built_in">bind</span>(foo, std::placeholders::_1, <span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 这时调用 bindFoo 时，只需要提供第一个参数即可</span></span><br><span class="line">    <span class="built_in">bindFoo</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示：</strong>注意 <code>auto</code> 关键字的妙用。有时候我们可能不太熟悉一个函数的返回值类型，<br>但是我们却可以通过 <code>auto</code> 的使用来规避这一问题的出现。</p>
</blockquote>
<h2 id="3-3-右值引用"><a href="#3-3-右值引用" class="headerlink" title="3.3 右值引用"></a>3.3 右值引用</h2><p>右值引用是 C++11 引入的与 Lambda 表达式齐名的重要特性之一。它的引入解决了 C++ 中大量的历史遗留问题，<br>消除了诸如 <code>std::vector</code>、<code>std::string</code> 之类的额外开销，<br>也才使得函数对象容器 <code>std::function</code> 成为了可能。</p>
<h3 id="左值、右值的纯右值、将亡值、右值"><a href="#左值、右值的纯右值、将亡值、右值" class="headerlink" title="左值、右值的纯右值、将亡值、右值"></a>左值、右值的纯右值、将亡值、右值</h3><p>要弄明白右值引用到底是怎么一回事，必须要对左值和右值做一个明确的理解。</p>
<p>**左值(lvalue, left value)**，顾名思义就是赋值符号左边的值。准确来说，<br>左值是表达式（不一定是赋值表达式）后依然存在的持久对象。</p>
<p>**右值(rvalue, right value)**，右边的值，是指表达式结束后就不再存在的临时对象。</p>
<p>而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。</p>
<p>**纯右值(prvalue, pure rvalue)**，纯粹的右值，要么是纯粹的字面量，例如 <code>10</code>, <code>true</code>；<br>要么是求值结果相当于字面量或匿名临时对象，例如 <code>1+2</code>。非引用返回的临时变量、运算表达式产生的临时变量、<br>原始字面量、Lambda 表达式都属于纯右值。</p>
<p>需要注意的是，字符串字面量只有在类中才是右值，当其位于普通函数中是左值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>*&amp;&amp; right = <span class="string">&quot;this is a rvalue&quot;</span>; <span class="comment">// 此处字符串字面量为右值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            right = <span class="string">&quot;still rvalue&quot;</span>; <span class="comment">// 此处字符串字面量为右值</span></span><br><span class="line">        &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;left = <span class="string">&quot;this is an lvalue&quot;</span>; <span class="comment">// 此处字符串字面量为左值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**将亡值(xvalue, expiring value)**，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++ 中，<br>纯右值和右值是同一个概念），也就是即将被销毁、却能够被移动的值。</p>
<p>将亡值可能稍有些难以理解，我们来看这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; temp = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = <span class="built_in">foo</span>();</span><br></pre></td></tr></table></figure>

<p>在这样的代码中，就传统的理解而言，函数 <code>foo</code> 的返回值 <code>temp</code> 在内部创建然后被赋值给 <code>v</code>，<br>然而 <code>v</code> 获得这个对象时，会将整个 <code>temp</code> 拷贝一份，然后把 <code>temp</code> 销毁，如果这个 <code>temp</code> 非常大，<br>这将造成大量额外的开销（这也就是传统 C++ 一直被诟病的问题）。在最后一行中，<code>v</code> 是左值、<br><code>foo()</code> 返回的值就是右值（也是纯右值）。但是，<code>v</code> 可以被别的变量捕获到，<br>而 <code>foo()</code> 产生的那个返回值作为一个临时值，一旦被 <code>v</code> 复制后，将立即被销毁，无法获取、也不能修改。<br>而将亡值就定义了这样一种行为：临时的值能够被识别、同时又能够被移动。</p>
<p>在 C++11 之后，编译器为我们做了一些工作，此处的左值 <code>temp</code> 会被进行此隐式右值转换，<br>等价于 <code>static_cast&lt;std::vector&lt;int&gt; &amp;&amp;&gt;(temp)</code>，进而此处的 <code>v</code> 会将 <code>foo</code> 局部返回的值进行移动。<br>也就是后面我们将会提到的移动语义。</p>
<h3 id="右值引用和左值引用"><a href="#右值引用和左值引用" class="headerlink" title="右值引用和左值引用"></a>右值引用和左值引用</h3><p>要拿到一个将亡值，就需要用到右值引用：<code>T &amp;&amp;</code>，其中 <code>T</code> 是类型。<br>右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。</p>
<p>C++11 提供了 <code>std::move</code> 这个方法将左值参数无条件的转换为右值，<br>有了它我们就能够方便的获得一个右值临时对象，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;左值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(std::string&amp;&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;右值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string lv1 = <span class="string">&quot;string,&quot;</span>; <span class="comment">// lv1 是一个左值</span></span><br><span class="line">    <span class="comment">// std::string&amp;&amp; r1 = lv1; // 非法, 右值引用不能引用左值</span></span><br><span class="line">    std::string&amp;&amp; rv1 = std::<span class="built_in">move</span>(lv1); <span class="comment">// 合法, std::move可以将左值转移为右值</span></span><br><span class="line">    std::cout &lt;&lt; rv1 &lt;&lt; std::endl; <span class="comment">// string,</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::string&amp; lv2 = lv1 + lv1; <span class="comment">// 合法, 常量左值引用能够延长临时变量的生命周期</span></span><br><span class="line">    <span class="comment">// lv2 += &quot;Test&quot;; // 非法, 常量引用无法被修改</span></span><br><span class="line">    std::cout &lt;&lt; lv2 &lt;&lt; std::endl; <span class="comment">// string,string,</span></span><br><span class="line"></span><br><span class="line">    std::string&amp;&amp; rv2 = lv1 + lv2; <span class="comment">// 合法, 右值引用延长临时对象生命周期</span></span><br><span class="line">    rv2 += <span class="string">&quot;Test&quot;</span>; <span class="comment">// 合法, 非常量引用能够修改临时变量</span></span><br><span class="line">    std::cout &lt;&lt; rv2 &lt;&lt; std::endl; <span class="comment">// string,string,string,Test</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">reference</span>(rv2); <span class="comment">// 输出左值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rv2</code> 虽然引用了一个右值，但由于它是一个引用，所以 <code>rv2</code> 依然是一个左值。</p>
<p>注意，这里有一个很有趣的历史遗留问题，我们先看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int &amp;a = std::move(1);    // 不合法，非常量左引用无法引用右值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;b = std::<span class="built_in">move</span>(<span class="number">1</span>); <span class="comment">// 合法, 常量左引用允许引用右值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个问题，为什么不允许非常量引用绑定到非左值？这是因为这种做法存在逻辑错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">(<span class="type">int</span> &amp; v)</span> </span>&#123;</span><br><span class="line">    v++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">increase</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>int&amp;</code> 不能引用 <code>double</code> 类型的参数，因此必须产生一个临时值来保存 <code>s</code> 的值，<br>从而当 <code>increase()</code> 修改这个临时值时，调用完成后 <code>s</code> 本身并没有被修改。</p>
<p>第二个问题，为什么常量引用允许绑定到非左值？原因很简单，因为 Fortran 需要。</p>
<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>传统 C++ 通过拷贝构造函数和赋值操作符为类对象设计了拷贝&#x2F;复制的概念，但为了实现对资源的移动操作，<br>调用者必须使用先复制、再析构的方式，否则就需要自己实现移动对象的接口。<br>试想，搬家的时候是把家里的东西直接搬到新家去，而不是将所有东西复制一份（重买）再放到新家、<br>再把原来的东西全部扔掉（销毁），这是非常反人类的一件事情。</p>
<p>传统的 C++ 没有区分『移动』和『拷贝』的概念，造成了大量的数据拷贝，浪费时间和空间。<br>右值引用的出现恰好就解决了这两个概念的混淆问题，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *pointer;</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">pointer</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>)) &#123; </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;构造&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(A&amp; a):<span class="built_in">pointer</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.pointer)) &#123; </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;拷贝&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl; </span><br><span class="line">    &#125; <span class="comment">// 无意义的对象拷贝</span></span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; a):<span class="built_in">pointer</span>(a.pointer) &#123; </span><br><span class="line">        a.pointer = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;移动&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123; </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;析构&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl; </span><br><span class="line">        <span class="keyword">delete</span> pointer; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 防止编译器优化</span></span><br><span class="line"><span class="function">A <span class="title">return_rvalue</span><span class="params">(<span class="type">bool</span> test)</span> </span>&#123;</span><br><span class="line">    A a,b;</span><br><span class="line">    <span class="keyword">if</span>(test) <span class="keyword">return</span> a; <span class="comment">// 等价于 static_cast&lt;A&amp;&amp;&gt;(a);</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> b;     <span class="comment">// 等价于 static_cast&lt;A&amp;&amp;&gt;(b);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A obj = <span class="built_in">return_rvalue</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; obj.pointer &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; *obj.pointer &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中：</p>
<ol>
<li>首先会在 <code>return_rvalue</code> 内部构造两个 <code>A</code> 对象，于是获得两个构造函数的输出；</li>
<li>函数返回后，产生一个将亡值，被 <code>A</code> 的移动构造（<code>A(A&amp;&amp;)</code>）引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 <code>obj</code> 中，而将亡值的指针被设置为 <code>nullptr</code>，防止了这块内存区域被销毁。</li>
</ol>
<p>从而避免了无意义的拷贝构造，加强了性能。再来看看涉及标准库的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// std::move</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">// std::string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::string str = <span class="string">&quot;Hello world.&quot;</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将使用 push_back(const T&amp;), 即产生拷贝行为</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(str);</span><br><span class="line">    <span class="comment">// 将输出 &quot;str: Hello world.&quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将使用 push_back(const T&amp;&amp;), 不会出现拷贝行为</span></span><br><span class="line">    <span class="comment">// 而整个字符串会被移动到 vector 中，所以有时候 std::move 会用来减少拷贝出现的开销</span></span><br><span class="line">    <span class="comment">// 这步操作后, str 中的值会变为空</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(str));</span><br><span class="line">    <span class="comment">// 将输出 &quot;str: &quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><p>前面我们提到了，一个声明的右值引用其实是一个左值。这就为我们进行参数转发（传递）造成了问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;左值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;右值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;普通传参:&quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(v); <span class="comment">// 始终调用 reference(int&amp;)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;传递右值:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">pass</span>(<span class="number">1</span>); <span class="comment">// 1是右值, 但输出是左值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;传递左值:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pass</span>(l); <span class="comment">// l 是左值, 输出左值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 <code>pass(1)</code> 来说，虽然传递的是右值，但由于 <code>v</code> 是一个引用，所以同时也是左值。<br>因此 <code>reference(v)</code> 会调用 <code>reference(int&amp;)</code>，输出『左值』。<br>而对于<code>pass(l)</code>而言，<code>l</code>是一个左值，为什么会成功传递给 <code>pass(T&amp;&amp;)</code> 呢？</p>
<p>这是基于<strong>引用坍缩规则</strong>的：在传统 C++ 中，我们不能够对一个引用类型继续进行引用，<br>但 C++ 由于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则，允许我们对引用进行引用，<br>既能左引用，又能右引用。但是却遵循如下规则：</p>
<table>
<thead>
<tr>
<th align="center">函数形参类型</th>
<th align="center">实参参数类型</th>
<th align="center">推导后函数形参类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T&amp;</td>
<td align="center">左引用</td>
<td align="center">T&amp;</td>
</tr>
<tr>
<td align="center">T&amp;</td>
<td align="center">右引用</td>
<td align="center">T&amp;</td>
</tr>
<tr>
<td align="center">T&amp;&amp;</td>
<td align="center">左引用</td>
<td align="center">T&amp;</td>
</tr>
<tr>
<td align="center">T&amp;&amp;</td>
<td align="center">右引用</td>
<td align="center">T&amp;&amp;</td>
</tr>
</tbody></table>
<p>因此，模板函数中使用 <code>T&amp;&amp;</code> 不一定能进行右值引用，当传入左值时，此函数的引用将被推导为左值。<br>更准确的讲，<strong>无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为右引用类型</strong>。<br>这才使得 <code>v</code> 作为左值的成功传递。</p>
<p>完美转发就是基于上述规律产生的。所谓完美转发，就是为了让我们在传递参数的时候，<br>保持原来的参数类型（左引用保持左引用，右引用保持右引用）。<br>为了解决这个问题，我们应该使用 <code>std::forward</code> 来进行参数的转发（传递）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;左值引用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;右值引用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;              普通传参: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(v);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;       std::move 传参: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(std::<span class="built_in">move</span>(v));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;    std::forward 传参: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(std::forward&lt;T&gt;(v));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;static_cast&lt;T&amp;&amp;&gt; 传参: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(<span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;传递右值:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">pass</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;传递左值:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pass</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">传递右值:</span><br><span class="line">              普通传参: 左值引用</span><br><span class="line">       std::move 传参: 右值引用</span><br><span class="line">    std::forward 传参: 右值引用</span><br><span class="line">static_cast&lt;T&amp;&amp;&gt; 传参: 右值引用</span><br><span class="line">传递左值:</span><br><span class="line">              普通传参: 左值引用</span><br><span class="line">       std::move 传参: 右值引用</span><br><span class="line">    std::forward 传参: 左值引用</span><br><span class="line">static_cast&lt;T&amp;&amp;&gt; 传参: 左值引用</span><br></pre></td></tr></table></figure>

<p>无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发，<br>所以 <code>std::move</code> 总会接受到一个左值，从而转发调用了<code>reference(int&amp;&amp;)</code> 输出右值引用。</p>
<p>唯独 <code>std::forward</code> 即没有造成任何多余的拷贝，同时<strong>完美转发</strong>(传递)了函数的实参给了内部调用的其他函数。</p>
<p><code>std::forward</code> 和 <code>std::move</code> 一样，没有做任何事情，<code>std::move</code> 单纯的将左值转化为右值，<br><code>std::forward</code> 也只是单纯的将参数做了一个类型的转换，从现象上来看，<br><code>std::forward&lt;T&gt;(v)</code> 和 <code>static_cast&lt;T&amp;&amp;&gt;(v)</code> 是完全一样的。</p>
<p>读者可能会好奇，为何一条语句能够针对两种类型的返回对应的值，<br>我们再简单看一看 <code>std::forward</code> 的具体实现机制，<code>std::forward</code> 包含两个重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">&quot;template argument&quot;</span></span><br><span class="line">        <span class="string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这份实现中，<code>std::remove_reference</code> 的功能是消除类型中的引用，<br>而 <code>std::is_lvalue_reference</code> 用于检查类型推导是否正确，在 <code>std::forward</code> 的第二个实现中<br>检查了接收到的值确实是一个左值，进而体现了坍缩规则。</p>
<p>当 <code>std::forward</code> 接受左值时，<code>_Tp</code> 被推导为左值，所以返回值为左值；而当其接受右值时，<br><code>_Tp</code> 被推导为 右值引用，则基于坍缩规则，返回值便成为了 <code>&amp;&amp; + &amp;&amp;</code> 的右值。<br>可见 <code>std::forward</code> 的原理在于巧妙的利用了模板类型推导中产生的差异。</p>
<p>这时我们能回答这样一个问题：为什么在使用循环语句的过程中，<code>auto&amp;&amp;</code> 是最安全的方式？<br>因为当 <code>auto</code> 被推导为不同的左右引用时，与 <code>&amp;&amp;</code> 的坍缩组合是完美转发。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章介绍了现代 C++ 中最为重要的几个语言运行时的增强，其中笔者认为本节中提到的所有特性都是值得掌握的：</p>
<ol>
<li>Lambda 表达式</li>
<li>函数对象容器 std::function</li>
<li>右值引用</li>
</ol>
<p><a href="../toc.md">返回目录</a> | <a href="../02-usability.md">上一章</a> | <a href="../04-containers.md">下一章 容器</a></p>
<h2 id="进一步阅读的参考文献"><a href="#进一步阅读的参考文献" class="headerlink" title="进一步阅读的参考文献"></a>进一步阅读的参考文献</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.amazon.cn/dp/B007JFSCPY">Bjarne Stroustrup, C++ 语言的设计与演化</a></li>
</ul>
<h2 id="许可"><a href="#许可" class="headerlink" title="许可"></a>许可</h2><p><a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png" /></a></p>
<p>本教程由<a target="_blank" rel="noopener" href="https://github.com/changkun">欧长坤</a>撰写，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>许可。项目中代码使用 MIT 协议开源，参见<a href="../../LICENSE">许可</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/14/02-usability/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LiuXin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Golden age">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/14/02-usability/" class="post-title-link" itemprop="url">第 2 章 语言可用性的强化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-14 21:12:58" itemprop="dateCreated datePublished" datetime="2022-05-14T21:12:58+08:00">2022-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-16 12:35:59" itemprop="dateModified" datetime="2022-05-16T12:35:59+08:00">2022-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8E%B0%E4%BB%A3C-%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">现代C++教程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第-2-章-语言可用性的强化"><a href="#第-2-章-语言可用性的强化" class="headerlink" title="第 2 章 语言可用性的强化"></a>第 2 章 语言可用性的强化</h1><p>当我们声明、定义一个变量或者常量，对代码进行流程控制、面向对象的功能、模板编程等这些都是运行时之前，可能发生在编写代码或编译器编译代码时的行为。为此，我们通常谈及<strong>语言可用性</strong>，是指那些发生在运行时之前的语言行为。</p>
<h2 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a>2.1 常量</h2><h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p><code>nullptr</code> 出现的目的是为了替代 <code>NULL</code>。在某种意义上来说，传统 C++ 会把 <code>NULL</code>、<code>0</code> 视为同一种东西，这取决于编译器如何定义 <code>NULL</code>，有些编译器会将 <code>NULL</code> 定义为 <code>((void*)0)</code>，有些则会直接将其定义为 <code>0</code>。</p>
<p>C++ <strong>不允许</strong>直接将 <code>void *</code> 隐式转换到其他类型。但如果编译器尝试把 <code>NULL</code> 定义为 <code>((void*)0)</code>，那么在下面这句代码中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *ch = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>没有了 <code>void *</code> 隐式转换的 C++ 只好将 <code>NULL</code> 定义为 <code>0</code>。而这依然会产生新的问题，将 <code>NULL</code> 定义成 <code>0</code> 将导致 <code>C++</code> 中重载特性发生混乱。考虑下面这两个 <code>foo</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>那么 <code>foo(NULL);</code> 这个语句将会去调用 <code>foo(int)</code>，从而导致代码违反直觉。</p>
<p>为了解决这个问题，C++11 引入了 <code>nullptr</code> 关键字，专门用来区分空指针、<code>0</code>。而 <code>nullptr</code> 的类型为 <code>nullptr_t</code>，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p>
<p>你可以尝试使用 <code>clang++</code> 编译下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>(<span class="number">0</span>)&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NULL == 0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>((<span class="type">void</span>*)<span class="number">0</span>)&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NULL == (void *)0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), std::<span class="type">nullptr_t</span>&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NULL == nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">0</span>);          <span class="comment">// 调用 foo(int)</span></span><br><span class="line">    <span class="comment">// foo(NULL);    // 该行不能通过编译</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="literal">nullptr</span>);    <span class="comment">// 调用 foo(char*)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> *)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(char*) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(int) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(int) is called</span><br><span class="line">foo(char*) is called</span><br></pre></td></tr></table></figure>

<p>从输出中我们可以看出，<code>NULL</code> 不同于 <code>0</code> 与 <code>nullptr</code>。所以，请养成直接使用 <code>nullptr</code>的习惯。</p>
<p>此外，在上面的代码中，我们使用了 <code>decltype</code> 和 <code>std::is_same</code> 这两个属于现代 C++ 的语法，简单来说，<code>decltype</code> 用于类型推导，而 <code>std::is_same</code> 用于比较两个类型是否相同，我们会在后面 <a href="#decltype">decltype</a> 一节中详细讨论。</p>
<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>C++ 本身已经具备了常量表达式的概念，比如 <code>1+2</code>, <code>3*4</code> 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。一个非常明显的例子就是在数组的定义阶段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">len_foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">len_foo_constexpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">2</span> ? <span class="number">1</span> : <span class="built_in">fibonacci</span>(n<span class="number">-1</span>)+<span class="built_in">fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arr_1[<span class="number">10</span>];                      <span class="comment">// 合法</span></span><br><span class="line">    <span class="type">char</span> arr_2[LEN];                     <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// char arr_3[len];                  // 非法</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len_2 = len + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> len_2_constexpr = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// char arr_4[len_2];                // 非法</span></span><br><span class="line">    <span class="type">char</span> arr_4[len_2_constexpr];         <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// char arr_5[len_foo()+5];          // 非法</span></span><br><span class="line">    <span class="type">char</span> arr_6[<span class="built_in">len_foo_constexpr</span>() + <span class="number">1</span>]; <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">fibonacci</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 1, 1, 2, 3, 5, 8, 13, 21, 34, 55</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">fibonacci</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>char arr_4[len_2]</code> 可能比较令人困惑，因为 <code>len_2</code> 已经被定义为了常量。为什么 <code>char arr_4[len_2]</code> 仍然是非法的呢？这是因为 C++ 标准中数组的长度必须是一个常量表达式，而对于 <code>len_2</code> 而言，这是一个 <code>const</code> 常数，而不是一个常量表达式，因此（即便这种行为在大部分编译器中都支持，但是）它是一个非法的行为，我们需要使用接下来即将介绍的 C++11 引入的 <code>constexpr</code> 特性来解决这个问题；而对于 <code>arr_5</code> 来说，C++98 之前的编译器无法得知 <code>len_foo()</code> 在运行期实际上是返回一个常数，这也就导致了非法的产生。</p>
<blockquote>
<p>注意，现在大部分编译器其实都带有自身编译优化，很多非法行为在编译器优化的加持下会变得合法，若需重现编译报错的现象需要使用老版本的编译器。</p>
</blockquote>
<p>C++11 提供了 <code>constexpr</code> 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这个关键字明确的告诉编译器应该去验证 <code>len_foo</code> 在编译期就应该是一个常量表达式。</p>
<p>此外，<code>constexpr</code> 修饰的函数可以使用递归：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">2</span> ? <span class="number">1</span> : <span class="built_in">fibonacci</span>(n<span class="number">-1</span>)+<span class="built_in">fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 C++14 开始，<code>constexpr</code> 函数可以在内部使用局部变量、循环和分支等简单语句，例如下面的代码在 C++11 的标准下是不能够通过编译的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n<span class="number">-1</span>) + <span class="built_in">fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为此，我们可以写出下面这类简化的版本来使得函数从 C++11 开始即可用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">2</span> ? <span class="number">1</span> : <span class="built_in">fibonacci</span>(n<span class="number">-1</span>) + <span class="built_in">fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-变量及其初始化"><a href="#2-2-变量及其初始化" class="headerlink" title="2.2 变量及其初始化"></a>2.2 变量及其初始化</h2><h3 id="if-x2F-switch-变量声明强化"><a href="#if-x2F-switch-变量声明强化" class="headerlink" title="if&#x2F;switch 变量声明强化"></a>if&#x2F;switch 变量声明强化</h3><p>在传统 C++ 中，变量的声明虽然能够位于任何位置，甚至于 <code>for</code> 语句内能够声明一个临时变量 <code>int</code>，但始终没有办法在 <code>if</code> 和 <code>switch</code> 语句中声明一个临时的变量。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 c++17 之前</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator itr = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (itr != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        *itr = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要重新定义一个新的变量</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator itr2 = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (itr2 != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        *itr2 = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将输出 1, 4, 3, 4</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator element = vec.<span class="built_in">begin</span>(); element != vec.<span class="built_in">end</span>(); ++element)</span><br><span class="line">        std::cout &lt;&lt; *element &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们可以看到 <code>itr</code> 这一变量是定义在整个 <code>main()</code> 的作用域内的，这导致当我们需要再次遍历整个 <code>std::vectors</code> 时，需要重新命名另一个变量。C++17 消除了这一限制，使得我们可以在 <code>if</code>（或 <code>switch</code>）中完成这一操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将临时变量放到 if 语句内</span></span><br><span class="line"><span class="keyword">if</span> (<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator itr = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    itr != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    *itr = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎么样，是不是和 Go 语言很像？</p>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>初始化是一个非常重要的语言特性，最常见的就是在对象进行初始化时进行使用。<br>在传统 C++ 中，不同的对象有着不同的初始化方法，例如普通数组、<br>POD （<strong>P</strong>lain <strong>O</strong>ld <strong>D</strong>ata，即没有构造、析构和虚函数的类或结构体）<br>类型都可以使用 <code>&#123;&#125;</code> 进行初始化，也就是我们所说的初始化列表。<br>而对于类对象的初始化，要么需要通过拷贝构造、要么就需要使用 <code>()</code> 进行。<br>这些不同方法都针对各自对象，不能通用。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value_a;</span><br><span class="line">    <span class="type">int</span> value_b;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">value_a</span>(a), <span class="built_in">value_b</span>(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// before C++11</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="function">Foo <span class="title">foo</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;arr[0]: &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo:&quot;</span> &lt;&lt; foo.value_a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; foo.value_b &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，C++11 首先把初始化列表的概念绑定到了类型上，并将其称之为 <code>std::initializer_list</code>，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MagicFoo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">MagicFoo</span>(std::initializer_list&lt;<span class="type">int</span>&gt; list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (std::initializer_list&lt;<span class="type">int</span>&gt;::iterator it = list.<span class="built_in">begin</span>();</span><br><span class="line">             it != list.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// after C++11</span></span><br><span class="line">    MagicFoo magicFoo = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;magicFoo: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = magicFoo.vec.<span class="built_in">begin</span>(); it != magicFoo.vec.<span class="built_in">end</span>(); ++it) std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种构造函数被叫做初始化列表构造函数，具有这种构造函数的类型将在初始化时被特殊关照。</p>
<p>初始化列表除了用在对象构造上，还能将其作为普通函数的形参，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (std::initializer_list&lt;<span class="type">int</span>&gt;::iterator it = list.<span class="built_in">begin</span>();</span><br><span class="line">            it != list.<span class="built_in">end</span>(); ++it) vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">magicFoo.<span class="built_in">foo</span>(&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>其次，C++11 还提供了统一的语法来初始化任意的对象，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo foo2 &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h3><p>结构化绑定提供了类似其他语言中提供的多返回值的功能。在容器一章中，我们会学到 C++11 新增了 <code>std::tuple</code> 容器用于构造一个元组，进而囊括多个返回值。但缺陷是，C++11&#x2F;14 并没有提供一种简单的方法直接从元组中拿到并定义元组中的元素，尽管我们可以使用 <code>std::tie</code> 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型，非常麻烦。</p>
<p>C++17 完善了这一设定，给出的结构化绑定可以让我们写出这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2.3</span>, <span class="string">&quot;456&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [x, y, z] = <span class="built_in">f</span>();</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 <code>auto</code> 类型推导会在 <a href="#auto">auto 类型推导</a>一节中进行介绍。</p>
<h2 id="2-3-类型推导"><a href="#2-3-类型推导" class="headerlink" title="2.3 类型推导"></a>2.3 类型推导</h2><p>在传统 C 和 C++ 中，参数的类型都必须明确定义，这其实对我们快速进行编码没有任何帮助，尤其是当我们面对一大堆复杂的模板类型时，必须明确的指出变量的类型才能进行后续的编码，这不仅拖慢我们的开发效率，也让代码变得又臭又长。</p>
<p>C++11 引入了 <code>auto</code> 和 <code>decltype</code> 这两个关键字实现了类型推导，让编译器来操心变量的类型。这使得 C++ 也具有了和其他现代编程语言一样，某种意义上提供了无需操心变量类型的使用习惯。</p>
<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p><code>auto</code> 在很早以前就已经进入了 C++，但是他始终作为一个存储类型的指示符存在，与 <code>register</code> 并存。在传统 C++ 中，如果一个变量没有声明为 <code>register</code> 变量，将自动被视为一个 <code>auto</code> 变量。而随着 <code>register</code> 被弃用（在 C++17 中作为保留关键字，以后使用，目前不具备实际意义），对 <code>auto</code> 的语义变更也就非常自然了。</p>
<p>使用 <code>auto</code> 进行类型推导的一个最为常见而且显著的例子就是迭代器。你应该在前面的小节里看到了传统 C++ 中冗长的迭代写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 C++11 之前</span></span><br><span class="line"><span class="comment">// 由于 cbegin() 将返回 vector&lt;int&gt;::const_iterator</span></span><br><span class="line"><span class="comment">// 所以 itr 也应该是 vector&lt;int&gt;::const_iterator 类型</span></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::const_iterator it = vec.<span class="built_in">cbegin</span>(); itr != vec.<span class="built_in">cend</span>(); ++it)</span><br></pre></td></tr></table></figure>

<p>而有了 <code>auto</code> 之后可以：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MagicFoo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">MagicFoo</span>(std::initializer_list&lt;<span class="type">int</span>&gt; list) &#123;</span><br><span class="line">        <span class="comment">// 从 C++11 起, 使用 auto 关键字进行类型推导</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MagicFoo magicFoo = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;magicFoo: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = magicFoo.vec.<span class="built_in">begin</span>(); it != magicFoo.vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些其他的常见用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>;              <span class="comment">// i 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> arr = <span class="keyword">new</span> <span class="built_in">auto</span>(<span class="number">10</span>); <span class="comment">// arr 被推导为 int *</span></span><br></pre></td></tr></table></figure>

<p>从 C++ 20 起，<code>auto</code> 甚至能用于函数传参，考虑下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>; <span class="comment">// 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> j = <span class="number">6</span>; <span class="comment">// 被推导为 int</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">add</span>(i, j) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：<code>auto</code> 还不能用于推导数组类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> auto_arr2[<span class="number">10</span>] = &#123;arr&#125;; <span class="comment">// 错误, 无法推导数组元素类型</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.6</span>.<span class="keyword">auto</span>.cpp:<span class="number">30</span>:<span class="number">19</span>: error: <span class="string">&#x27;auto_arr2&#x27;</span> declared as array of <span class="string">&#x27;auto&#x27;</span></span><br><span class="line">    <span class="keyword">auto</span> auto_arr2[<span class="number">10</span>] = &#123;arr&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p><code>decltype</code> 关键字是为了解决 <code>auto</code> 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 <code>typeof</code> 很相似：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(表达式)</span><br></pre></td></tr></table></figure>

<p>有时候，我们可能需要计算某个表达式的类型，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) z;</span><br></pre></td></tr></table></figure>

<p>你已经在前面的例子中看到 <code>decltype</code> 用于推断类型的用法，下面这个例子就是判断上面的变量 <code>x, y, z</code> 是否是同一类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(x), <span class="type">int</span>&gt;::value)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type x == int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(x), <span class="type">float</span>&gt;::value)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type x == float&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(x), <span class="keyword">decltype</span>(z)&gt;::value)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type z == type x&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>其中，<code>std::is_same&lt;T, U&gt;</code> 用于判断 <code>T</code> 和 <code>U</code> 这两个类型是否相等。输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type x == int</span><br><span class="line">type z == type x</span><br></pre></td></tr></table></figure>

<h3 id="尾返回类型推导"><a href="#尾返回类型推导" class="headerlink" title="尾返回类型推导"></a>尾返回类型推导</h3><p>你可能会思考，在介绍 <code>auto</code> 时，我们已经提过 <code>auto</code> 不能用于函数形参进行类型推导，那么 <code>auto</code> 能不能用于推导函数的返回类型呢？还是考虑一个加法函数的例子，在传统 C++ 中我们必须这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：typename 和 class 在模板参数列表中没有区别，在 typename 这个关键字出现之前，都是使用 class 来定义模板参数的。但在模板中定义有<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/dependent_name#The_typename_disambiguator_for_dependent_names">嵌套依赖类型</a>的变量时，需要用 typename 消除歧义</p>
</blockquote>
<p>这样的代码其实变得很丑陋，因为程序员在使用这个模板函数的时候，必须明确指出返回类型。但事实上我们并不知道 <code>add()</code> 这个函数会做什么样的操作，以及获得一个什么样的返回类型。</p>
<p>在 C++11 中这个问题得到解决。虽然你可能马上会反应出来使用 <code>decltype</code> 推导 <code>x+y</code> 的类型，写出这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(x+y) <span class="built_in">add</span>(T x, U y)</span><br></pre></td></tr></table></figure>

<p>但事实上这样的写法并不能通过编译。这是因为在编译器读到 decltype(x+y) 时，<code>x</code> 和 <code>y</code> 尚未被定义。为了解决这个问题，C++11 还引入了一个叫做尾返回类型（trailing return type），利用 <code>auto</code> 关键字将返回类型后置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add2</span><span class="params">(T x, U y)</span> -&gt; <span class="title">decltype</span><span class="params">(x+y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>令人欣慰的是从 C++14 开始是可以直接让普通函数具备返回值推导，因此下面的写法变得合法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add3</span><span class="params">(T x, U y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以检查一下类型推导是否正确：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// after c++11</span></span><br><span class="line"><span class="keyword">auto</span> w = <span class="built_in">add2</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(w), <span class="type">double</span>&gt;::value) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w is double: &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; w &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after c++14</span></span><br><span class="line"><span class="keyword">auto</span> q = <span class="built_in">add3</span>&lt;<span class="type">double</span>, <span class="type">int</span>&gt;(<span class="number">1.0</span>, <span class="number">2</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;q: &quot;</span> &lt;&lt; q &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h3 id="decltype-auto"><a href="#decltype-auto" class="headerlink" title="decltype(auto)"></a>decltype(auto)</h3><p><code>decltype(auto)</code> 是 C++14 开始提供的一个略微复杂的用法。</p>
<blockquote>
<p>要理解它你需要知道 C++ 中参数转发的概念，我们会在<a href="./03-runtime.md">语言运行时强化</a>一章中详细介绍，你可以到时再回来看这一小节的内容。</p>
</blockquote>
<p>简单来说，<code>decltype(auto)</code> 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的指定 <code>decltype</code> 的参数表达式。考虑看下面的例子，当我们需要对下面两个函数进行封装时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string  <span class="title">lookup1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::string&amp; <span class="title">lookup2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>在 C++11 中，封装实现是如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">look_up_a_string_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookup1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string&amp; <span class="title">look_up_a_string_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookup2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而有了 <code>decltype(auto)</code>，我们可以让编译器完成这一件烦人的参数转发：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">look_up_a_string_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookup1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">look_up_a_string_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookup2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-4-控制流"><a href="#2-4-控制流" class="headerlink" title="2.4 控制流"></a>2.4 控制流</h2><h3 id="if-constexpr"><a href="#if-constexpr" class="headerlink" title="if constexpr"></a>if constexpr</h3><p>正如本章开头出，我们知道了 C++11 引入了 <code>constexpr</code> 关键字，它将表达式或函数编译为常量结果。一个很自然的想法是，如果我们把这一特性引入到条件判断中去，让代码在编译时就完成分支判断，岂不是能让程序效率更高？C++17 将 <code>constexpr</code> 这个关键字引入到 <code>if</code> 语句中，允许在代码中声明常量表达式的判断条件，考虑下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">print_type_info</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral&lt;T&gt;::value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">3.14</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译时，实际代码就会表现为如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">print_type_info</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">print_type_info</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">3.14</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区间-for-迭代"><a href="#区间-for-迭代" class="headerlink" title="区间 for 迭代"></a>区间 for 迭代</h3><p>终于，C++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句，我们可以进一步简化前面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> itr = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>); itr != vec.<span class="built_in">end</span>()) *itr = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; std::endl; <span class="comment">// read only</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;element : vec) &#123;</span><br><span class="line">        element += <span class="number">1</span>;                      <span class="comment">// writeable</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; std::endl; <span class="comment">// read only</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-模板"><a href="#2-5-模板" class="headerlink" title="2.5 模板"></a>2.5 模板</h2><p>C++ 的模板一直是这门语言的一种特殊的艺术，模板甚至可以独立作为一门新的语言来进行使用。模板的哲学在于将一切能够在编译期处理的问题丢到编译期进行处理，仅在运行时处理那些最核心的动态服务，进而大幅优化运行期的性能。因此模板也被很多人视作 C++ 的黑魔法之一。</p>
<h3 id="外部模板"><a href="#外部模板" class="headerlink" title="外部模板"></a>外部模板</h3><p>传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板的实例化。</p>
<p>为此，C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能够显式的通知编译器何时进行模板的实例化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">std</span>::vector&lt;<span class="type">bool</span>&gt;;          <span class="comment">// 强行实例化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">std</span>::vector&lt;<span class="type">double</span>&gt;; <span class="comment">// 不在该当前编译文件中实例化模板</span></span><br></pre></td></tr></table></figure>

<h3 id="尖括号-“-gt-”"><a href="#尖括号-“-gt-”" class="headerlink" title="尖括号 “&gt;”"></a>尖括号 “&gt;”</h3><p>在传统 C++ 的编译器中，<code>&gt;&gt;</code>一律被当做右移运算符来进行处理。但实际上我们很容易就写出了嵌套模板的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; matrix;</span><br></pre></td></tr></table></figure>

<p>这在传统 C++ 编译器下是不能够被编译的，而 C++11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。甚至于像下面这种写法都能够通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MagicType</span> &#123;</span><br><span class="line">    <span class="type">bool</span> magic = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in main function:</span></span><br><span class="line">std::vector&lt;MagicType&lt;(1&gt;<span class="number">2</span>)&gt;&gt; magic; <span class="comment">// 合法, 但不建议写出这样的代码</span></span><br></pre></td></tr></table></figure>

<h3 id="类型别名模板"><a href="#类型别名模板" class="headerlink" title="类型别名模板"></a>类型别名模板</h3><p>在了解类型别名模板之前，需要理解『模板』和『类型』之间的不同。仔细体会这句话：<strong>模板是用来产生类型的。</strong>在传统 C++ 中，<code>typedef</code>  可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MagicType</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T dark;</span><br><span class="line">    U magic;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不合法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typedef</span> MagicType&lt;std::vector&lt;T&gt;, std::string&gt; FakeDarkMagic;</span><br></pre></td></tr></table></figure>

<p>C++11 使用 <code>using</code> 引入了下面这种形式的写法，并且同时支持对传统 <code>typedef</code> 相同的功效：</p>
<blockquote>
<p>通常我们使用 <code>typedef</code> 定义别名的语法是：<code>typedef 原名称 新名称;</code>，但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*process)</span><span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line"><span class="keyword">using</span> NewProcess = <span class="built_in">int</span>(*)(<span class="type">void</span> *);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> TrueDarkMagic = MagicType&lt;std::vector&lt;T&gt;, std::string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TrueDarkMagic&lt;<span class="type">bool</span>&gt; you;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变长参数模板"><a href="#变长参数模板" class="headerlink" title="变长参数模板"></a>变长参数模板</h3><p>模板一直是 C++ 所独有的<strong>黑魔法</strong>（一起念：<strong>Dark Magic</strong>）之一。<br>在 C++11 之前，无论是类模板还是函数模板，都只能按其指定的样子，<br>接受一组固定数量的模板参数；而 C++11 加入了新的表示方法，<br>允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt; <span class="keyword">class</span> <span class="title class_">Magic</span>;</span><br></pre></td></tr></table></figure>

<p>模板类 Magic 的对象，能够接受不受限制个数的 typename 作为模板的形式参数，例如下面的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Magic</span>&lt;<span class="type">int</span>,</span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt;,</span><br><span class="line">            std::map&lt;std::string,</span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt;&gt;&gt; darkMagic;</span><br></pre></td></tr></table></figure>

<p>既然是任意形式，所以个数为 <code>0</code> 的模板参数也是可以的：<code>class Magic&lt;&gt; nothing;</code>。</p>
<p>如果不希望产生的模板参数个数为 <code>0</code>，可以手动的定义至少一个模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Require, <span class="keyword">typename</span>... Args&gt; <span class="keyword">class</span> <span class="title class_">Magic</span>;</span><br></pre></td></tr></table></figure>

<p>变长参数模板也能被直接调整到到模板函数上。传统 C 中的 <code>printf</code> 函数，<br>虽然也能达成不定个数的形参的调用，但其并非类别安全。<br>而 C++11 除了能定义类别安全的变长参数函数外，<br>还可以使类似 <code>printf</code> 的函数能自然地处理非自带类别的对象。<br>除了在模板参数中能使用 <code>...</code> 表示不定长模板参数外，<br>函数参数也使用同样的表示法代表不定长参数，<br>这也就为我们简单编写变长参数函数提供了便捷的手段，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt; <span class="type">void</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> std::string &amp;str, Args... args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>那么我们定义了变长的模板参数，如何对参数进行解包呢？</p>
<p>首先，我们可以使用 <code>sizeof...</code> 来计算参数的个数，：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">magic</span><span class="params">(Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以传递任意个参数给 <code>magic</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">magic</span>(); <span class="comment">// 输出0</span></span><br><span class="line"><span class="built_in">magic</span>(<span class="number">1</span>); <span class="comment">// 输出1</span></span><br><span class="line"><span class="built_in">magic</span>(<span class="number">1</span>, <span class="string">&quot;&quot;</span>); <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure>

<p>其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理手法：</p>
<p><strong>1. 递归模板函数</strong></p>
<p>递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归地向函数传递模板参数，进而达到递归遍历所有模板参数的目的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf1</span><span class="params">(T0 value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf1</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printf1</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf1</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;123&quot;</span>, <span class="number">1.1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 变参模板展开</strong></p>
<p>你应该感受到了这很繁琐，在 C++17 中增加了变参模板展开的支持，于是你可以在一个函数中完成 <code>printf</code> 的编写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf2</span><span class="params">(T0 t0, T... t)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; t0 &lt;&lt; std::endl;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(t) &gt; <span class="number">0</span>)</span> <span class="title">printf2</span><span class="params">(t...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事实上，有时候我们虽然使用了变参模板，却不一定需要对参数做逐个遍历，我们可以利用 <code>std::bind</code> 及完美转发等特性实现对函数和参数的绑定，从而达到成功调用的目的。</p>
</blockquote>
<p><strong>3. 初始化列表展开</strong></p>
<p>递归模板函数是一种标准的做法，但缺点显而易见的在于必须定义一个终止递归的函数。</p>
<p>这里介绍一种使用初始化列表展开的黑魔法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">printf3</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    (<span class="type">void</span>) std::initializer_list&lt;T&gt;&#123;([&amp;args] &#123;</span><br><span class="line">        std::cout &lt;&lt; args &lt;&lt; std::endl;</span><br><span class="line">    &#125;(), value)...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个代码中，额外使用了 C++11 中提供的初始化列表以及 Lambda 表达式的特性（下一节中将提到）。</p>
<p>通过初始化列表，<code>(lambda 表达式, value)...</code> 将会被展开。由于逗号表达式的出现，首先会执行前面的 lambda 表达式，完成参数的输出。<br>为了避免编译器警告，我们可以将 <code>std::initializer_list</code> 显式的转为 <code>void</code>。</p>
<h3 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h3><p>C++ 17 中将变长参数这种特性进一步带给了表达式，考虑下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T ... t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t + ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非类型模板参数推导"><a href="#非类型模板参数推导" class="headerlink" title="非类型模板参数推导"></a>非类型模板参数推导</h3><p>前面我们主要提及的是模板参数的一种形式：类型模板参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中模板的参数 <code>T</code> 和 <code>U</code> 为具体的类型。<br>但还有一种常见模板参数形式可以让不同字面量成为模板参数，即非类型模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> BufSize&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">buffer_t</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T&amp; <span class="title">alloc</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(T&amp; item)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[BufSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">buffer_t</span>&lt;<span class="type">int</span>, <span class="number">100</span>&gt; buf; <span class="comment">// 100 作为模板参数</span></span><br></pre></td></tr></table></figure>

<p>在这种模板参数形式下，我们可以将 <code>100</code> 作为模板的参数进行传递。<br>在 C++11 引入了类型推导这一特性后，我们会很自然的问，既然此处的模板参数<br>以具体的字面量进行传递，能否让编译器辅助我们进行类型推导，<br>通过使用占位符 <code>auto</code> 从而不再需要明确指明类型？<br>幸运的是，C++17 引入了这一特性，我们的确可以 <code>auto</code> 关键字，让编译器辅助完成具体类型的推导，<br>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> value&gt; <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>&lt;<span class="number">10</span>&gt;();  <span class="comment">// value 被推导为 int 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-面向对象"><a href="#2-6-面向对象" class="headerlink" title="2.6 面向对象"></a>2.6 面向对象</h2><h3 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h3><p>C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value1;</span><br><span class="line">    <span class="type">int</span> value2;</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        value1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> value) : <span class="built_in">Base</span>() &#123; <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">        value2 = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; b.value1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; b.value2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h3><p>在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++11 利用关键字 <code>using</code> 引入了继承构造函数的概念：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value1;</span><br><span class="line">    <span class="type">int</span> value2;</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        value1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> value) : <span class="built_in">Base</span>() &#123; <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">        value2 = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subclass</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base; <span class="comment">// 继承构造</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Subclass <span class="title">s</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; s.value1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; s.value2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="显式虚函数重载"><a href="#显式虚函数重载" class="headerlink" title="显式虚函数重载"></a>显式虚函数重载</h3><p>在传统 C++ 中，经常容易发生意外重载虚函数的事情。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass</span>: Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>SubClass::foo</code> 可能并不是程序员尝试重载虚函数，只是恰好加入了一个具有相同名字的函数。另一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再重载该虚拟函数并摇身一变成为了一个普通的类方法，这将造成灾难性的后果。</p>
<p>C++11 引入了 <code>override</code> 和 <code>final</code> 这两个关键字来防止上述情形的发生。</p>
<h4 id="override"><a href="#override" class="headerlink" title="override"></a>override</h4><p>当重载虚函数时，引入 <code>override</code> 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass</span>: Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 合法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">float</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 非法, 父类没有此虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p><code>final</code> 则是为了防止类被继续继承以及终止虚函数继续重载引入的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass1</span> <span class="keyword">final</span>: Base &#123;</span><br><span class="line">&#125;; <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass2</span> : SubClass1 &#123;</span><br><span class="line">&#125;; <span class="comment">// 非法, SubClass1 已 final</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass3</span>: Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// 非法, foo 已 final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="显式禁用默认函数"><a href="#显式禁用默认函数" class="headerlink" title="显式禁用默认函数"></a>显式禁用默认函数</h3><p>在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成默认构造函数、<br>复制构造、赋值算符以及析构函数。<br>另外，C++ 也为所有类定义了诸如 <code>new</code> <code>delete</code> 这样的运算符。<br>当程序员有需要时，可以重载这部分函数。</p>
<p>这就引发了一些需求：无法精确控制默认函数的生成行为。<br>例如禁止类的拷贝时，必须将复制构造函数与赋值算符声明为 <code>private</code>。<br>尝试使用这些未定义的函数将导致编译或链接错误，则是一种非常不优雅的方式。</p>
<p>并且，编译器产生的默认构造函数与用户定义的构造函数无法同时存在。<br>若用户定义了任何构造函数，编译器将不再生成默认构造函数，<br>但有时候我们却希望同时拥有这两种构造函数，这就造成了尴尬。</p>
<p>C++11 提供了上述需求的解决方案，允许显式的声明采用或拒绝编译器自带的函数。<br>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Magic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Magic</span>() = <span class="keyword">default</span>; <span class="comment">// 显式声明使用编译器生成的构造</span></span><br><span class="line">    Magic&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Magic&amp;) = <span class="keyword">delete</span>; <span class="comment">// 显式声明拒绝编译器生成构造</span></span><br><span class="line">    <span class="built_in">Magic</span>(<span class="type">int</span> magic_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h3><p>在传统 C++中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类型可以进行直接的比较（虽然编译器给出了检查，但并非所有），<strong>甚至同一个命名空间中的不同枚举类型的枚举值名字不能相同</strong>，这通常不是我们希望看到的结果。</p>
<p>C++11 引入了枚举类（enumeration class），并使用 <code>enum class</code> 的语法进行声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">new_enum</span> : <span class="type">unsigned</span> <span class="type">int</span> &#123;</span><br><span class="line">    value1,</span><br><span class="line">    value2,</span><br><span class="line">    value3 = <span class="number">100</span>,</span><br><span class="line">    value4 = <span class="number">100</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较，<br>更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那么可以进行比较：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (new_enum::value3 == new_enum::value4) &#123;</span><br><span class="line">    <span class="comment">// 会输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;new_enum::value3 == new_enum::value4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个语法中，枚举类型后面使用了冒号及类型关键字来指定枚举中枚举值的类型，这使得我们能够为枚举赋值（未指定时将默认使用 <code>int</code>）。</p>
<p>而我们希望获得枚举值的值时，将必须显式的进行类型转换，不过我们可以通过重载 <code>&lt;&lt;</code> 这个算符来进行输出，可以收藏下面这个代码段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;std::is_enum&lt;T&gt;::value,</span><br><span class="line">        std::ostream&gt;::type&amp; stream, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> stream &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::underlying_type&lt;T&gt;::type&gt;(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，下面的代码将能够被编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; new_enum::value3 &lt;&lt; std::endl</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节介绍了现代 C++ 中对语言可用性的增强，其中笔者认为最为重要的几个特性是几乎所有人都需要了解并熟练使用的：</p>
<ol>
<li><code>auto</code> 类型推导</li>
<li>范围 <code>for</code> 迭代</li>
<li>初始化列表</li>
<li>变参模板</li>
</ol>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ol>
<li><p>使用结构化绑定，仅用一行函数内代码实现如下函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(std::map&lt;Key, Value&gt;&amp; m, F foo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt; m &#123;</span><br><span class="line">        &#123;<span class="string">&quot;a&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;b&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;c&quot;</span>, <span class="number">3</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">update</span>(m, [](std::string key) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::hash&lt;std::string&gt;&#123;&#125;(key);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; [key, value] : m)</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尝试用<a href="#%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F">折叠表达式</a>实现用于计算均值的函数，传入允许任意参数。</p>
</li>
</ol>
<blockquote>
<p>参考答案<a href="../../exercises/2">见此</a>。</p>
</blockquote>
<p><a href="../toc.md">返回目录</a> | <a href="../01-intro.md">上一章</a> | <a href="../03-runtime.md">下一章 运行时强化</a></p>
<h2 id="许可"><a href="#许可" class="headerlink" title="许可"></a>许可</h2><p><a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png" /></a></p>
<p>本书系<a target="_blank" rel="noopener" href="https://github.com/changkun">欧长坤</a>著，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>许可。项目中代码使用 MIT 协议开源，参见<a href="../../LICENSE">许可</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/26/hello-world-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LiuXin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Golden age">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/26/hello-world-1/" class="post-title-link" itemprop="url">英语课程时间安排</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-26 21:38:58" itemprop="dateCreated datePublished" datetime="2022-04-26T21:38:58+08:00">2022-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-29 09:38:59" itemprop="dateModified" datetime="2022-04-29T09:38:59+08:00">2022-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <table>
<thead>
<tr>
<th><strong>Week</strong></th>
<th><strong>Course   Contents</strong></th>
<th><strong>Time</strong></th>
<th><strong>Tutorial</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>2-3</strong></td>
<td><strong>Orientation Session</strong></td>
<td><strong>2.28  – 3.13</strong></td>
<td><strong>熟悉政策、注册平台和课程、购买教材</strong></td>
</tr>
<tr>
<td><strong>4-5</strong></td>
<td><strong>1. Unit 1 Thinking</strong></td>
<td><strong>3.14 –3.27</strong></td>
<td><strong>注意： 慕课截止时间为截止日期当晚 23:30（不是24:00）</strong></td>
</tr>
<tr>
<td><strong>6-7</strong></td>
<td><strong>2. Unit 2 Life</strong></td>
<td><strong>3.28 – 4.10</strong></td>
<td></td>
</tr>
<tr>
<td><strong>8-9</strong></td>
<td><strong>3. Unit 3 Technology</strong>  <br />  <strong>Test One</strong></td>
<td><strong>4.11 – 4.24</strong></td>
<td></td>
</tr>
<tr>
<td><strong>10-11</strong></td>
<td><strong>4. Unit 4 Health</strong></td>
<td><strong>4.25 – 5.8</strong></td>
<td></td>
</tr>
<tr>
<td><strong>12-13</strong></td>
<td><strong>5. Unit 6 Education</strong></td>
<td><strong>5.9 –5.22</strong></td>
<td></td>
</tr>
<tr>
<td><strong>14-15</strong></td>
<td><strong>6. Unit 8 Family</strong>  <br /><strong>Test Two</strong></td>
<td><strong>5.23 – 6.5</strong></td>
<td></td>
</tr>
<tr>
<td><strong>16</strong></td>
<td><strong>Q &amp; A Session</strong></td>
<td><strong>6.6  – 6.12</strong></td>
<td></td>
</tr>
</tbody></table>
<p><img src="/images/hello-world-1/image-20220429093537160.png" alt="image-20220429093537160"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/26/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LiuXin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Golden age">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/26/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-26 20:40:02" itemprop="dateCreated datePublished" datetime="2022-04-26T20:40:02+08:00">2022-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-27 10:14:33" itemprop="dateModified" datetime="2022-04-27T10:14:33+08:00">2022-04-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">LiuXin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiuXin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
